<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="1" failures="8" skipped="0" tests="22" time="0.504" timestamp="2025-01-21T17:27:13.193460" hostname="Mac.hsd1.fl.comcast.net"><testcase classname="tests.test_ci_setup" name="test_basic_addition" time="0.001" /><testcase classname="tests.test_ci_setup" name="test_basic_subtraction" time="0.000" /><testcase classname="tests.test_ci_setup" name="test_environmental_setup" time="0.000" /><testcase classname="tests.database.test_connections" name="test_postgres_connection" time="0.022"><error message="failed on setup with &quot;psycopg2.OperationalError: connection to server at &quot;localhost&quot; (::1), port 5432 failed: FATAL:  database &quot;test_gen_db&quot; does not exist&quot;">@pytest.fixture
    def postgres_connection():
        """Create a PostgreSQL connection for testing."""
&gt;       conn = psycopg2.connect(
            dbname="test_gen_db",
            user=os.getenv("POSTGRES_USER", "postgres"),
            password=os.getenv("POSTGRES_PASSWORD"),
            host=os.getenv("POSTGRES_HOST", "localhost"),
            port=os.getenv("POSTGRES_PORT", "5432")
        )

tests/database/test_connections.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dsn = 'dbname=test_gen_db user=postgres password=A7B29C3846 host=localhost port=5432', connection_factory = None, cursor_factory = None
kwargs = {'dbname': 'test_gen_db', 'host': 'localhost', 'password': 'A7B29C3846', 'port': '5432', ...}, kwasync = {}

    def connect(dsn=None, connection_factory=None, cursor_factory=None, **kwargs):
        """
        Create a new database connection.
    
        The connection parameters can be specified as a string:
    
            conn = psycopg2.connect("dbname=test user=postgres password=secret")
    
        or using a set of keyword arguments:
    
            conn = psycopg2.connect(database="test", user="postgres", password="secret")
    
        Or as a mix of both. The basic connection parameters are:
    
        - *dbname*: the database name
        - *database*: the database name (only as keyword argument)
        - *user*: user name used to authenticate
        - *password*: password used to authenticate
        - *host*: database host address (defaults to UNIX socket if not provided)
        - *port*: connection port number (defaults to 5432 if not provided)
    
        Using the *connection_factory* parameter a different class or connections
        factory can be specified. It should be a callable object taking a dsn
        argument.
    
        Using the *cursor_factory* parameter, a new default cursor factory will be
        used by cursor().
    
        Using *async*=True an asynchronous connection will be created. *async_* is
        a valid alias (for Python versions where ``async`` is a keyword).
    
        Any other keyword parameter will be passed to the underlying client
        library: the list of supported parameters depends on the library version.
    
        """
        kwasync = {}
        if 'async' in kwargs:
            kwasync['async'] = kwargs.pop('async')
        if 'async_' in kwargs:
            kwasync['async_'] = kwargs.pop('async_')
    
        dsn = _ext.make_dsn(dsn, **kwargs)
&gt;       conn = _connect(dsn, connection_factory=connection_factory, **kwasync)
E       psycopg2.OperationalError: connection to server at "localhost" (::1), port 5432 failed: FATAL:  database "test_gen_db" does not exist

venv/lib/python3.11/site-packages/psycopg2/__init__.py:122: OperationalError</error></testcase><testcase classname="tests.database.test_connections" name="test_mongo_connection" time="0.030" /><testcase classname="tests.integration.test_app_integration.TestCodeAnalysis" name="test_code_analysis_workflow" time="0.151"><failure message="assert 404 == &lt;HTTPStatus.OK: 200&gt;&#10; +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code&#10; +  and   &lt;HTTPStatus.OK: 200&gt; = HTTPStatus.OK">self = &lt;test_app_integration.TestCodeAnalysis object at 0x1084b72d0&gt;, client = &lt;FlaskClient &lt;Flask 'src.app'&gt;&gt;
test_db = &lt;connection object at 0x10840bb50; dsn: 'user=postgres password=xxx dbname=test_db_31634 host=localhost', closed: 0&gt;, mock_mongodb = mongomock.MongoClient('localhost', 27017)

    def test_code_analysis_workflow(self, client, test_db, mock_mongodb):
        """Test the complete code analysis workflow."""
        # Setup
        auth_headers = AuthTestHelper.get_auth_headers()
        test_code = TestDataGenerator.generate_test_code_snippet()
    
        # Submit code for analysis
        response = client.post(
            '/api/analyze',
            json=test_code,
            headers=auth_headers
        )
&gt;       assert response.status_code == HTTPStatus.OK
E       assert 404 == &lt;HTTPStatus.OK: 200&gt;
E        +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code
E        +  and   &lt;HTTPStatus.OK: 200&gt; = HTTPStatus.OK

tests/integration/test_app_integration.py:22: AssertionError</failure></testcase><testcase classname="tests.integration.test_app_integration.TestPatternLearning" name="test_pattern_storage_workflow" time="0.000"><failure message="TypeError: TestPatternLearning.test_pattern_storage_workflow() missing 2 required positional arguments: 'client' and 'mock_mongodb'">args = (&lt;test_app_integration.TestPatternLearning object at 0x1084b7a10&gt;,), kwargs = {}
asyncio = &lt;module 'asyncio' from '/opt/homebrew/Cellar/python@3.11/3.11.11/Frameworks/Python.framework/Versions/3.11/lib/python3.11/asyncio/__init__.py'&gt;

    def wrapper(*args, **kwargs):
        import asyncio
&gt;       return asyncio.run(coro(*args, **kwargs))
E       TypeError: TestPatternLearning.test_pattern_storage_workflow() missing 2 required positional arguments: 'client' and 'mock_mongodb'

tests/helpers.py:95: TypeError</failure></testcase><testcase classname="tests.integration.test_app_integration.TestTestGeneration" name="test_test_generation_workflow" time="0.059"><failure message="assert 404 == &lt;HTTPStatus.OK: 200&gt;&#10; +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code&#10; +  and   &lt;HTTPStatus.OK: 200&gt; = HTTPStatus.OK">self = &lt;test_app_integration.TestTestGeneration object at 0x1084d02d0&gt;, client = &lt;FlaskClient &lt;Flask 'src.app'&gt;&gt;
test_db = &lt;connection object at 0x108615540; dsn: 'user=postgres password=xxx dbname=test_db_31634 host=localhost', closed: 0&gt;

    def test_test_generation_workflow(self, client, test_db):
        """Test the complete test generation workflow."""
        # Setup
        auth_headers = AuthTestHelper.get_auth_headers()
        test_code = TestDataGenerator.generate_test_code_snippet()
    
        # Request test generation
        response = client.post(
            '/api/generate-tests',
            json=test_code,
            headers=auth_headers
        )
&gt;       assert response.status_code == HTTPStatus.OK
E       assert 404 == &lt;HTTPStatus.OK: 200&gt;
E        +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code
E        +  and   &lt;HTTPStatus.OK: 200&gt; = HTTPStatus.OK

tests/integration/test_app_integration.py:76: AssertionError</failure></testcase><testcase classname="tests.integration.test_app_integration.TestTestGeneration" name="test_test_execution_workflow" time="0.053"><failure message="assert 404 == &lt;HTTPStatus.OK: 200&gt;&#10; +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code&#10; +  and   &lt;HTTPStatus.OK: 200&gt; = HTTPStatus.OK">self = &lt;test_app_integration.TestTestGeneration object at 0x1084d0990&gt;, client = &lt;FlaskClient &lt;Flask 'src.app'&gt;&gt;
test_db = &lt;connection object at 0x1086157e0; dsn: 'user=postgres password=xxx dbname=test_db_31634 host=localhost', closed: 0&gt;

    def test_test_execution_workflow(self, client, test_db):
        """Test the execution of generated tests."""
        # Setup
        auth_headers = AuthTestHelper.get_auth_headers()
        test_code = TestDataGenerator.generate_test_code_snippet()
    
        # Generate and execute tests
        response = client.post(
            '/api/execute-tests',
            json={
                'code': test_code['code'],
                'tests': [
                    'def test_add_numbers():\n    assert add_numbers(1, 2) == 3'
                ]
            },
            headers=auth_headers
        )
&gt;       assert response.status_code == HTTPStatus.OK
E       assert 404 == &lt;HTTPStatus.OK: 200&gt;
E        +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code
E        +  and   &lt;HTTPStatus.OK: 200&gt; = HTTPStatus.OK

tests/integration/test_app_integration.py:104: AssertionError</failure></testcase><testcase classname="tests.integration.test_app_integration.TestErrorHandling" name="test_invalid_code_submission" time="0.003"><failure message="assert 404 == &lt;HTTPStatus.BAD_REQUEST: 400&gt;&#10; +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code&#10; +  and   &lt;HTTPStatus.BAD_REQUEST: 400&gt; = HTTPStatus.BAD_REQUEST">self = &lt;test_app_integration.TestErrorHandling object at 0x1084d11d0&gt;, client = &lt;FlaskClient &lt;Flask 'src.app'&gt;&gt;

    def test_invalid_code_submission(self, client):
        """Test error handling for invalid code submission."""
        auth_headers = AuthTestHelper.get_auth_headers()
    
        response = client.post(
            '/api/analyze',
            json={'code': None},
            headers=auth_headers
        )
&gt;       assert response.status_code == HTTPStatus.BAD_REQUEST
E       assert 404 == &lt;HTTPStatus.BAD_REQUEST: 400&gt;
E        +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code
E        +  and   &lt;HTTPStatus.BAD_REQUEST: 400&gt; = HTTPStatus.BAD_REQUEST

tests/integration/test_app_integration.py:120: AssertionError</failure></testcase><testcase classname="tests.integration.test_app_integration.TestErrorHandling" name="test_authentication_error" time="0.002"><failure message="assert 404 == &lt;HTTPStatus.UNAUTHORIZED: 401&gt;&#10; +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code&#10; +  and   &lt;HTTPStatus.UNAUTHORIZED: 401&gt; = HTTPStatus.UNAUTHORIZED">self = &lt;test_app_integration.TestErrorHandling object at 0x1084d1890&gt;, client = &lt;FlaskClient &lt;Flask 'src.app'&gt;&gt;

    def test_authentication_error(self, client):
        """Test error handling for invalid authentication."""
        response = client.post(
            '/api/analyze',
            json=TestDataGenerator.generate_test_code_snippet()
        )
&gt;       assert response.status_code == HTTPStatus.UNAUTHORIZED
E       assert 404 == &lt;HTTPStatus.UNAUTHORIZED: 401&gt;
E        +  where 404 = &lt;WrapperTestResponse streamed [404 NOT FOUND]&gt;.status_code
E        +  and   &lt;HTTPStatus.UNAUTHORIZED: 401&gt; = HTTPStatus.UNAUTHORIZED

tests/integration/test_app_integration.py:129: AssertionError</failure></testcase><testcase classname="tests.unit.test_app" name="test_app_creation" time="0.001" /><testcase classname="tests.unit.test_app" name="test_health_check_success" time="0.002" /><testcase classname="tests.unit.test_app" name="test_health_check_method_not_allowed" time="0.003" /><testcase classname="tests.unit.test_app" name="test_not_found_error_response" time="0.002" /><testcase classname="tests.unit.test_app" name="test_not_found_error_different_paths" time="0.002" /><testcase classname="tests.unit.test_config" name="test_config_loads_environment_variables" time="0.001"><failure message="AssertionError: assert 'postgresql:/...2/test_gen_db' == 'postgresql:/...:5432/test_db'&#10;  - postgresql://test:test@localhost:5432/test_db&#10;  ?              ----------&#10;  + postgresql://localhost:5432/test_gen_db&#10;  ?                                  ++++">mock_env_vars = None

    def test_config_loads_environment_variables(mock_env_vars):
        """Test that configuration loads from environment variables."""
        config = Config()
&gt;       assert config.database_url == 'postgresql://test:test@localhost:5432/test_db'
E       AssertionError: assert 'postgresql:/...2/test_gen_db' == 'postgresql:/...:5432/test_db'
E         - postgresql://test:test@localhost:5432/test_db
E         ?              ----------
E         + postgresql://localhost:5432/test_gen_db
E         ?                                  ++++

tests/unit/test_config.py:16: AssertionError</failure></testcase><testcase classname="tests.unit.test_config" name="test_config_uses_defaults_when_env_vars_missing" time="0.001"><failure message="AssertionError: assert 'postgresql:/...2/test_gen_db' == 'postgresql:/...:5432/test_db'&#10;  - postgresql://test:test@localhost:5432/test_db&#10;  ?              ----------&#10;  + postgresql://localhost:5432/test_gen_db&#10;  ?                                  ++++">monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x1086b7fd0&gt;

    def test_config_uses_defaults_when_env_vars_missing(monkeypatch):
        """Test that configuration uses defaults when environment variables are not set."""
        # Clear any existing environment variables
        monkeypatch.delenv('DATABASE_URL', raising=False)
        monkeypatch.delenv('MONGODB_URL', raising=False)
        monkeypatch.delenv('SECRET_KEY', raising=False)
        monkeypatch.delenv('DEBUG', raising=False)
    
        config = Config()
&gt;       assert config.database_url == 'postgresql://test:test@localhost:5432/test_db'
E       AssertionError: assert 'postgresql:/...2/test_gen_db' == 'postgresql:/...:5432/test_db'
E         - postgresql://test:test@localhost:5432/test_db
E         ?              ----------
E         + postgresql://localhost:5432/test_gen_db
E         ?                                  ++++

tests/unit/test_config.py:30: AssertionError</failure></testcase><testcase classname="tests.unit.test_config" name="test_config_validates_required_variables" time="0.001" /><testcase classname="tests.unit.test_config" name="test_config_validates_url_formats" time="0.000" /><testcase classname="tests.unit.test_config" name="test_config_as_dict" time="0.000" /><testcase classname="tests.unit.test_config" name="test_config_from_env" time="0.001" /></testsuite></testsuites>